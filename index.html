<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IBONARIUM · ART SPACE</title>
    <style>
        /* --- CORE RESET & FONTS --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            background-color: #000;
            color: #ffd166;
            font-family: "Courier New", monospace;
            overflow: hidden;
            /* We handle scrolling via JS for 3D navigation */
        }

        /* --- BACKGROUND --- */
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* --- UI / HUD --- */
        .ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .header {
            pointer-events: auto;
            text-shadow: 0 0 10px rgba(255, 209, 102, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .brand {
            font-size: 18px;
            letter-spacing: 2px;
            border: 1px solid #ffd166;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
        }

        .controls-hint {
            font-size: 10px;
            opacity: 0.7;
            text-align: right;
            line-height: 1.5;
        }

        .footer {
            pointer-events: auto;
            font-size: 10px;
            opacity: 0.6;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        /* --- 3D SCENE --- */
        #scene {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            perspective: 1200px;
            /* Depth of field */
            overflow: hidden;
            z-index: 10;
            cursor: grab;
        }

        #scene:active {
            cursor: grabbing;
        }

        #gallery-space {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform-style: preserve-3d;
            /* Will be manipulated by JS for movement */
        }

        /* --- ARTWORK ITEMS --- */
        .art-item {
            position: absolute;
            top: -100px;
            left: -100px;
            /* Centering helper */
            width: 200px;
            height: 200px;
            transform-style: preserve-3d;
            cursor: pointer;
            transition: opacity 0.5s ease;
            /* Visual style for the frames */
        }

        .art-content {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border: 1px solid rgba(255, 209, 102, 0.3);
            box-shadow: 0 0 15px rgba(255, 209, 102, 0.1);
            background: rgba(10, 10, 10, 0.8);
            transition: transform 0.3s, border-color 0.3s, box-shadow 0.3s;
            pointer-events: none;
            /* Let clicks pass to parent .art-item */
        }

        .art-item:hover .art-content {
            border-color: #ffd166;
            box-shadow: 0 0 30px rgba(255, 209, 102, 0.4);
            transform: scale(1.05);
        }

        .art-label {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 0 2px 4px #000;
            background: #000;
            padding: 2px 4px;
        }

        .art-item:hover .art-label {
            opacity: 1;
        }

        .video-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #ffd166;
            color: #000;
            font-size: 9px;
            padding: 2px 4px;
            font-weight: bold;
        }

        /* --- MODAL (OVERLAY) --- */
        #overlay {
            position: fixed;
            inset: 0;
            z-index: 200;
            background: rgba(0, 0, 0, 0.92);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
            backdrop-filter: blur(5px);
        }

        #overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .overlay-content {
            max-width: 90vw;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
        }

        #overlay-media-container {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid #ffd166;
            box-shadow: 0 0 50px rgba(255, 209, 102, 0.2);
            background: #000;
        }

        #overlay-media-container img,
        #overlay-media-container video {
            max-width: 80vw;
            max-height: 70vh;
            display: block;
        }

        .overlay-info {
            text-align: center;
            max-width: 600px;
        }

        .overlay-title {
            font-size: 18px;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }

        .overlay-desc {
            font-size: 12px;
            opacity: 0.7;
            line-height: 1.4;
        }

        .close-btn {
            position: absolute;
            top: -40px;
            right: 0;
            border: 1px solid #ffd166;
            background: transparent;
            color: #ffd166;
            width: 30px;
            height: 30px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: #ffd166;
            color: #000;
        }

        /* LOADING SCREEN */
        #loader {
            position: fixed;
            inset: 0;
            z-index: 500;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s;
        }

        .loader-bar {
            width: 200px;
            height: 2px;
            background: #333;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }

        .loader-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: #ffd166;
            transition: width 0.1s;
        }
    </style>
</head>

<body>

    <!-- Background Starfield -->
    <canvas id="bg-canvas"></canvas>

    <!-- User Interface -->
    <div class="ui-layer">
        <div class="header">
            <div class="brand">IBONARIUM<br><span style="font-size:10px; opacity:0.6;">GALLERY.SPACE</span></div>
            <div class="controls-hint">
                DRAG TO LOOK<br>
                SCROLL TO FLY<br>
                CLICK TO EXPAND
            </div>
        </div>
        <div class="footer">
            <div>COORDINATES: <span id="coords">0, 0, 0</span></div>
            <div>COLLECTION: <span id="item-count">0</span> / 100</div>
        </div>
    </div>

    <!-- 3D Environment -->
    <div id="scene">
        <div id="gallery-space">
            <!-- Generated Items Will Be Injected Here -->
        </div>
    </div>

    <!-- Overlay Modal -->
    <div id="overlay">
        <div class="overlay-content">
            <button class="close-btn" onclick="closeOverlay()">✕</button>
            <div id="overlay-media-container">
                <!-- Media Injected Here -->
            </div>
            <div class="overlay-info">
                <div class="overlay-title" id="overlay-title">PROJECT NAME</div>
                <div class="overlay-desc" id="overlay-desc">Description of the artwork or cosmic anomaly detected in
                    this sector.</div>
            </div>
        </div>
    </div>

    <!-- Loader -->
    <div id="loader">
        <div style="letter-spacing:3px; font-size:12px;">INITIALIZING VACUUM...</div>
        <div class="loader-bar">
            <div class="loader-fill" id="load-bar"></div>
        </div>
        <div id="load-text" style="font-size:10px; margin-top:5px; opacity:0.6;">0%</div>
    </div>

    <script>
        /**
         * IBONARIUM GALLERY ENGINE
         * Handles:
         * 1. Dynamic asset discovery (img1..50, vid1..50)
         * 2. 3D Positioning and Navigation
         * 3. Particle System (Stars/Geometry)
         */

        /* --- CONFIG --- */
        const CONFIG = {
            maxImages: 50,
            maxVideos: 50,
            folders: {
                media: 'media/' // Path relative to index.html
            },
            spread: 3000,    // How wide spread the items are
            depth: 4000      // How deep the gallery goes
        };

        /* --- STATE --- */
        const state = {
            items: [],
            loadedCount: 0,
            totalToLoad: CONFIG.maxImages + CONFIG.maxVideos,
            camera: { x: 0, y: 0, z: 1500, rotX: 0, rotY: 0 }, // Start further back
            targetCamera: { x: 0, y: 0, z: 1500, rotX: 0, rotY: 0 },
            dragging: false,
            lastMouse: { x: 0, y: 0 }
        };

        /* --- DOM ELEMENTS --- */
        const gallerySpace = document.getElementById('gallery-space');
        const loadFill = document.getElementById('load-bar');
        const loadText = document.getElementById('load-text');
        const loaderEl = document.getElementById('loader');
        const itemCountEl = document.getElementById('item-count');
        const coordsEl = document.getElementById('coords');

        /* --- INITIALIZATION --- */
        async function init() {
            await discoverAssets();
            createStarfield();
            animate();

            // Hide loader if at least one item or timeout
            setTimeout(() => {
                loaderEl.style.opacity = '0';
                setTimeout(() => loaderEl.remove(), 500);
            }, 1000 + (state.items.length * 50));
        }

        // Helper to check if file exists
        function checkFile(url, type, index) {
            return new Promise(resolve => {
                const el = type === 'video' ? document.createElement('video') : new Image();

                el.onload = el.onloadedmetadata = () => {
                    resolve({ exists: true, url, type, index, width: el.width || el.videoWidth, height: el.height || el.videoHeight });
                };
                el.onerror = () => {
                    resolve({ exists: false });
                };

                el.src = url;
                // For video metadata to load we might need minimal hints
                if (type === 'video') el.preload = 'metadata';
            });
        }

        async function discoverAssets() {
            const promises = [];

            // Queue Image Checks
            for (let i = 1; i <= CONFIG.maxImages; i++) {
                // Try .jpg, .jpeg, .png via simplistic guess (mostly just .jpg per user req, but let's try standard)
                // To keep it simple for user: force standard naming "img_N.jpg" and "vid_N.mp4"
                // User asked "1.jpg 1.mp4". Okay.
                promises.push(checkFile(`${CONFIG.folders.media}${i}.jpg`, 'image', i));
            }
            // Queue Video Checks
            for (let i = 1; i <= CONFIG.maxVideos; i++) {
                promises.push(checkFile(`${CONFIG.folders.media}${i}.mp4`, 'video', i));
            }

            // Process results
            let completed = 0;
            const rawResults = await Promise.all(promises.map(p => p.then(res => {
                completed++;
                const pct = Math.floor((completed / params_total_checks) * 100);
                // Update visual loader (approximate since we don't know total valid)
                updateLoader(pct);
                return res;
            })));

            const validItems = rawResults.filter(r => r.exists);
            state.items = validItems;
            itemCountEl.textContent = state.items.length;

            // Build 3D Scene
            validItems.forEach(createArtItem);
        }

        // Total checks to track progress
        const params_total_checks = CONFIG.maxImages + CONFIG.maxVideos;

        function updateLoader(pct) {
            loadFill.style.width = `${pct}%`;
            loadText.textContent = `${pct}%`;
        }

        function createArtItem(item) {
            const el = document.createElement('div');
            el.className = 'art-item';

            // Random Position in spherical/cloud distribution
            // We want a "tunnel" or "cloud" feel. Let's do a scattered cloud.
            const spread = CONFIG.spread;
            const x = (Math.random() - 0.5) * spread;
            const y = (Math.random() - 0.5) * (spread * 0.6); // Flatter y
            const z = (Math.random() - 0.5) * CONFIG.depth;

            el.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;

            // Custom Data attributes
            el.dataset.x = x;
            el.dataset.y = y;
            el.dataset.z = z;
            el.dataset.type = item.type;
            el.dataset.url = item.url;
            el.dataset.index = item.index;

            // Inner Content
            let contentHtml = '';
            if (item.type === 'image') {
                contentHtml = `<img src="${item.url}" class="art-content" loading="lazy">`;
            } else {
                contentHtml = `
      <video src="${item.url}" class="art-content" loop muted playsinline onmouseover="this.play()" onmouseout="this.pause()"></video>
      <div class="video-badge">MOV</div>
    `;
            }

            el.innerHTML = `
    ${contentHtml}
    <div class="art-label">WORK NO. ${item.index}</div>
  `;

            el.onclick = () => openOverlay(item);

            gallerySpace.appendChild(el);

            // Add geometric aesthetic connector (lines)
            // Optimization: Only draw lines if using Canvas overlay or limiting total lines
            // We'll leave strict DOM lines out for performance, CSS 3D handles the boxes well.
        }

        /* --- INTERACTION --- */
        function openOverlay(item) {
            const cont = document.getElementById('overlay-media-container');
            const title = document.getElementById('overlay-title');
            cont.innerHTML = '';

            if (item.type === 'image') {
                cont.innerHTML = `<img src="${item.url}">`;
            } else {
                cont.innerHTML = `<video src="${item.url}" controls autoplay loop></video>`;
            }

            title.textContent = `PROJECT FILE: ${item.index}`;
            document.getElementById('overlay').classList.add('active');
        }

        function closeOverlay() {
            document.getElementById('overlay').classList.remove('active');
            const cont = document.getElementById('overlay-media-container');
            setTimeout(() => cont.innerHTML = '', 400); // clear after fade
        }

        /* --- NAVIGATION & ANIMATION --- */
        document.addEventListener('mousedown', e => {
            state.dragging = true;
            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        });
        document.addEventListener('mouseup', () => state.dragging = false);
        document.addEventListener('mousemove', e => {
            if (!state.dragging) return;
            const dx = e.clientX - state.lastMouse.x;
            const dy = e.clientY - state.lastMouse.y;

            state.targetCamera.rotY += dx * 0.2;
            state.targetCamera.rotX -= dy * 0.2;

            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        });

        // Touch support 
        document.addEventListener('touchstart', e => {
            state.dragging = true;
            state.lastMouse.x = e.touches[0].clientX;
            state.lastMouse.y = e.touches[0].clientY;
        });
        document.addEventListener('touchend', () => state.dragging = false);
        document.addEventListener('touchmove', e => {
            if (!state.dragging) return;
            const dx = e.touches[0].clientX - state.lastMouse.x;
            const dy = e.touches[0].clientY - state.lastMouse.y;
            state.targetCamera.rotY += dx * 0.3;
            state.targetCamera.rotX -= dy * 0.3;
            state.lastMouse.x = e.touches[0].clientX;
            state.lastMouse.y = e.touches[0].clientY;
        });


        document.addEventListener('wheel', e => {
            e.preventDefault();
            // Move camera forward/backward
            // Standard wheel delta is ~100
            state.targetCamera.z -= e.deltaY * 2;
        }, { passive: false });


        function animate() {
            // Smooth Camera Lerp
            state.camera.x += (state.targetCamera.x - state.camera.x) * 0.05;
            state.camera.y += (state.targetCamera.y - state.camera.y) * 0.05;
            state.camera.z += (state.targetCamera.z - state.camera.z) * 0.05;
            state.camera.rotX += (state.targetCamera.rotX - state.camera.rotX) * 0.05;
            state.camera.rotY += (state.targetCamera.rotY - state.camera.rotY) * 0.05;

            // Apply Transform
            // We move the WORLD opposite to camera
            const rotX = state.camera.rotX;
            const rotY = state.camera.rotY;
            const tz = state.camera.z;

            // Transform sequence: translate Z (dolly), rotate (look), translate XY (pan if implemented)
            gallerySpace.style.transform = `
    translateZ(${tz}px)
    rotateX(${rotX}deg)
    rotateY(${rotY}deg)
  `;

            // HUD Updates
            updateHUD();

            requestAnimationFrame(animate);
        }

        function updateHUD() {
            coordsEl.textContent = `${Math.round(state.camera.x)}, ${Math.round(state.camera.y)}, ${Math.round(state.camera.z)}`;
        }


        /* --- BACKGROUND STARFIELD --- */
        function createStarfield() {
            const canvas = document.getElementById('bg-canvas');
            const ctx = canvas.getContext('2d');
            let width, height;
            const stars = [];

            function resize() {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', resize);
            resize();

            // Init Stars
            for (let i = 0; i < 400; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    z: Math.random() * 2 // Depth/Speed factor
                });
            }

            // Draw Line - Geometry
            function draw() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);

                ctx.fillStyle = '#ffd166';
                ctx.strokeStyle = 'rgba(255,209,102,0.15)';

                // Update & Draw
                stars.forEach(s => {
                    s.y -= s.z * 0.2; // Move up? Or maybe center out? Let's just drift slowly up
                    if (s.y < 0) { s.y = height; s.x = Math.random() * width; }

                    const size = s.z * 1.2;
                    ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                    ctx.fillRect(s.x, s.y, size, size);

                    // Geometric Connections (constellations)
                    // Check neighbors
                    stars.forEach(s2 => {
                        const dx = s.x - s2.x;
                        const dy = s.y - s2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 60) {
                            ctx.beginPath();
                            ctx.moveTo(s.x, s.y);
                            ctx.lineTo(s2.x, s2.y);
                            ctx.stroke();
                        }
                    });
                });

                requestAnimationFrame(draw);
            }
            draw();
        }

        // Start
        init();

    </script>
</body>

</html>
